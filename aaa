本项目用 C++11/14 + STL 开发：vector 管理骑手列表，deque 实现先来先服务队列，stream 读写并解析订单；用 OOP（继承/多态） 区分自行车和摩托车的规则。
The project is implemented in C++ using the STL: vector stores the rider list, deque implements an FCFS waiting queue, and stream utilities handle order file parsing and output; 
OOP (inheritance/polymorphism) is used to model different vehicle rules (bicycle vs moped).

程序启动后在堆上创建骑手并加入待命队列，逐行读取输入文件并以日期行触发上一日报表输出与每日重置、以订单行解析时间距离类型；
每处理一单先同步配送中骑手回队，再按 FCFS 遍历待命队列分配首个符合条件的骑手，最终在文件结束或日期切换时生成 .dat 汇总报告。
On startup, the program creates all rider objects on the heap and enqueues them in the waiting queue, then reads the input file line by line—using date lines to write the previous day’s report and reset daily mileage, 
and order lines to parse time, distance, and type—while for each order it first returns any riders whose return time has passed to the end of the queue, 
assigns the first eligible rider under the rules (vehicle permissions and remaining mileage), and finally generates a .dat summary when the file ends or a new date is encountered.


系统采用 std::deque 实现公平的先来先服务派单机制（骑手完成配送后回到队尾），并通过基类 can_take_order 的多态调用对不同车型规则进行验证：
自行车受优先单与单程 2 英里及日里程限制，而机车可接所有订单且不受里程限制。
The system uses a std::deque to enforce fair FCFS dispatching (returned riders are always appended to the back of the queue) 
and relies on polymorphic can_take_order checks to apply vehicle-specific rules: bicycles cannot take priority orders, 
are limited to 2.0 miles one-way and a daily mileage quota, while mopeds can take all orders with no mileage limit.

